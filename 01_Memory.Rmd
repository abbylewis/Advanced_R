---
title: "Memory"
author: "Abby Lewis, most text and figures copied from Hadley Wickham's textbook"
date: "2023-08-10"
output: html_document
---

# Names and values

## Introduction

In R, it is important to understand the distinction between an object and its name. Doing so will help you:

* More accurately predict the performance and memory usage of your code. 
* Write faster code by avoiding accidental copies, a major source of slow code. 
* Better understand R's functional programming tools.

The goal of this lesson is to help you understand the distinction between names and values, and when R will copy an object.

### Outline

### Prerequisites

We'll use the [lobstr](https://github.com/r-lib/lobstr) package to dig into the internal representation of R objects.

```{r setup}
library(lobstr)
```

## Binding basics

Computer Memory is information (like numbers or strings) that is for immediate use. When you put information there, it is located at some “address” on your computer, and you can retrieve it from that address.

The following puts the vector c(1, 2, 3) in memory, and binds the name x to it

```{r}
x <- c(1, 2, 3)
```

We can visualize this with a diagram:

![Binding x to the vector c(1, 2, 3)](diagrams/name-value/binding-1.png)

Thus, you can think of a name as a reference to a value. For example, if you run this code, you don't get another copy of the value `c(1, 2, 3)`, you get another binding to the existing object:

```{r}
y <- x
```

![Binding y to the same vector as x](diagrams/name-value/binding-2.png)

The function lobstr::obj_addr() let’s us see the address of this object. Note that it is the same for x and y

```{r}
lobstr::obj_addr(x)
lobstr::obj_addr(y)
```

These identifiers change every time you restart R.

### Copy on modify

If you modify y, then it will make a copy of this object and point y to that new object. This is called __copy-on-modify__

```{r}
y[[3]] <- 4
lobstr::obj_addr(x) #x has the same address (x does not change when you change y -- this is good!)
lobstr::obj_addr(y) #y has a new address
```

![Modifying y did not change x](diagrams/name-value/binding-3.png)

### `tracemem()`

You can use `base::tracemem()` to track whenever an object is copied. Once you call that function with an object, you'll get the object's current address. 

When using `tracemem()` interactively, you'll get different results inside of RStudio. The environment pane must make a reference to each object in order to display information about it. This distorts your interactive exploration but doesn't affect code inside of functions, and so doesn't affect performance during data analysis. 

```{r trace1, eval = FALSE}
x <- c(1, 2, 3)
tracemem(x) #displays the location of the object it is tracking
```

From then on, whenever that object is copied, `tracemem()` will print a message telling you which object was copied, its new address, and the sequence of calls that led to the copy.

If you modify `y` again, it won't get copied. That's because the new object now only has a single name bound to it, so R applies modify-in-place optimization.

You can explore this functionality interactively by modifying the function below:

```{r}
tracemem_example <- function(){
  x <- c(1, 2, 3)
  cat(tracemem(x), "\n") #initial address (using cat() to show message)
  y <- x
  y[[3]] <- 4L #copy
  x[[3]] <- 5L #no copy
  y[[3]] <- 5L #no copy
  untracemem(x) #untracemem() is the opposite of tracemem()
}
tracemem_example()
```

`untracemem()` is the opposite of `tracemem()`; it turns tracing off.

### Function calls

How would you diagram what happens within a function? Here's an example:

```{r}
f <- function(a) {
  a
}

x <- c(1, 2, 3)
cat(tracemem(x), "\n")

z <- f(x)
# there's no copy here!

untracemem(x)
```

While `f()` is running, the `a` inside the function points to the same value as the `x` does outside the function:

![a and x point to same values](diagrams/name-value/binding-f1.png)

The function `f()` is depicted by the yellow object on the right. It has a formal argument, `a`, which becomes a binding (indicated by dotted black line) in the execution environment (the gray box) when the function is run.

Once `f()` completes, `x` and `z` will point to the same object. 

![a and x point to same values](diagrams/name-value/binding-f2.png)

The object never gets copied because it never gets modified. If `f()` did modify `x`, R would create a new copy, and then `z` would bind that object.

```{r}
f <- function(a) {
  a[[1]] <- 2
}

x <- c(1, 2, 3)
tracemem(x)

z <- f(x)
# x gets copied here

untracemem(x)
```


### Lists

Recall that a list is a vector that can have elements of any type.

To do this, the list’s name points to a vector of references, and these point to the objects (note how this is different than atomic vectors!)

```{r list1}
l1 <- list(1, 2, 3)
```

![lists point to values](diagrams/name-value/list.png)

Copy on modify for a list only copies the references, so is much more memory efficient. This is called a __shallow copy__.

```{r list2, dependson = "list1"}
l2 <- l1
```

![list with two bindings](diagrams/name-value/l-modify-1.png)

```{r list3, dependson = "list2"}
l2[[3]] <- 4
```

![modified list](diagrams/name-value/l-modify-2.png)

To see values that are shared across lists, use `lobstr::ref()`. `ref()` prints the memory address of each object, along with a local ID so that you can easily cross-reference shared components.

```{r list4, dependson = "list3"}
ref(l1, l2)
```

### Data frames {#df-modify}

Data frames are lists of vectors, so copy-on-modify has important consequences when you modify a data frame. 

```{r}
d1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))
```

![dataframe is list of vectors](diagrams/name-value/dataframe.png)

If you modify a column, only _that_ column needs to be modified; the others will still point to their original references:

```{r}
d2 <- d1
d2[, 2] <- d2[, 2] * 2
```

![modify column](diagrams/name-value/d-modify-c.png)

However, if you modify a row, every column is modified, which means every column must be copied:

```{r}
d3 <- d1
d3[1, ] <- d3[1, ] * 3
```

![modify row](diagrams/name-value/d-modify-r.png)

### Character vectors

R uses a __global string pool__ where each element of a character vector is a pointer to a unique string in the pool. This substantially decreases the amount of memory a character vector uses.

![character pool](diagrams/name-value/character-2.png)

You can request that `ref()` show these references by setting the `character` argument to `TRUE`:

```{r}
x <- c("a", "a", "abc", "d")
ref(x, character = TRUE)
```

### Exercises

Explain the relationship between `a`, `b`, `c` and `d` in the following code:

```{r}
a <- 1:10
b <- a
c <- b
d <- 1:10
```

The following code accesses the mean function in multiple ways. Do they all point to the same underlying function object? Verify this with `lobstr::obj_addr()`.
    
```{r, eval = FALSE}
mean
base::mean
get("mean")
evalq(mean)
match.fun("mean")
```

Why is `tracemem(1:10)` not useful?

Sketch out the relationship between the following objects:

```{r}
a <- 1:10
b <- list(a, a)
c <- list(b, a, 1:10)
```

What happens when you run this code? Draw a picture.

```{r}
x <- list(1:10)
x[[2]] <- x
```
    
    
## Object size

You can find out how much memory an object takes with `lobstr::obj_size()`:

```{r}
obj_size(letters)
obj_size(ggplot2::diamonds)
```

Since the elements of lists are references to values, the size of a list might be much smaller than you expect:

```{r}
x <- runif(1e6)
obj_size(x)

y <- list(x, x, x)
obj_size(y)

obj_size(y)-obj_size(x)
```

`y` is only 80 bytes bigger than `x`. That's the size of an empty list with three elements:

```{r}
obj_size(list(NULL, NULL, NULL))
```

If you're running 32-bit R, you'll see slightly different sizes.

Similarly, because R uses a global string pool character vectors take up less memory than you might expect: repeating a string 100 times does not make it take up 100 times as much memory.

```{r}
banana <- "bananas bananas bananas"
obj_size(banana)
obj_size(rep(banana, 100))
```

References also make it challenging to think about the size of individual objects. `obj_size(x) + obj_size(y)` will only equal `obj_size(x, y)` if there are no shared values. Here, the combined size of `x` and `y` is the same as the size of `y`:

```{r}
obj_size(x, y)
obj_size(x, y) == obj_size(y)
```

Finally, R 3.5.0 and later versions have a feature that might lead to surprises: ALTREP, short for __alternative representation__. This allows R to represent certain types of vectors very compactly. The place you are most likely to see this is with `:` because instead of storing every single number in the sequence, R just stores the first and last number. This means that every sequence, no matter how large, is the same size:

```{r}
obj_size(1:3)
obj_size(1:1e3)
obj_size(1:1e6)
obj_size(1:1e9)
```

### Exercises

Predict the output of the following code:

```{r, results = FALSE}
a <- runif(1e6)
obj_size(a)

b <- list(a, a)
obj_size(b)
obj_size(a, b)

b[[1]][[1]] <- 10
obj_size(b)
obj_size(a, b)

b[[2]][[1]] <- 10
obj_size(b)
obj_size(a, b)
```

## Modify-in-place

As we've seen above, modifying an R object usually creates a copy. There are two exceptions:

* Objects with a single binding get a special performance optimisation.

* Environments, a special type of object, are always modified in place.

### Objects with a single binding {#single-binding}
\index{loops!avoiding copies in}

If an object has a single name bound to it, R will modify it in place:

```{r}
v <- c(1, 2, 3)
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/v-inplace-1.png")
```

```{r}
v[[3]] <- 4
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/v-inplace-2.png")
```

(Note the object IDs here: `v` continues to bind to the same object, `0x207`.)

Two complications make predicting exactly when R applies this optimisation challenging:

* When it comes to bindings, R can currently[^refcnt] only count 0, 1, 
  or many. That means that if an object has two bindings, and one goes away,
  the reference count does not go back to 1: one less than many is 
  still many. In turn, this means that R will make copies when it sometimes
  doesn't need to.
  
* Whenever you call the vast majority of functions, it makes a reference to the 
  object. The only exception are specially written "primitive" C functions. 
  These can only be written by R-core and occur mostly in the base package.

[^refcnt]: By the time you read this, this may have changed, as plans are afoot to improve reference counting: https://developer.r-project.org/Refcnt.html

Together, these two complications make it hard to predict whether or not a copy will occur. Instead, it's better to determine it empirically with `tracemem()`.

\index{loops!performance}
\index{for loops|see {loops}}
Let's explore the subtleties with a case study using for loops. For loops have a reputation for being slow in R, but often that slowness is caused by every iteration of the loop creating a copy. Consider the following code. It subtracts the median from each column of a large data frame: 

```{r, cache = TRUE}
x <- data.frame(matrix(runif(5 * 1e4), ncol = 5))
medians <- vapply(x, median, numeric(1))

for (i in seq_along(medians)) {
  x[[i]] <- x[[i]] - medians[[i]]
}
```

This loop is surprisingly slow because each iteration of the loop copies the data frame. You can see this by using `tracemem()`:

```{r, eval = FALSE}
cat(tracemem(x), "\n")

for (i in 1:5) {
  x[[i]] <- x[[i]] - medians[[i]]
}

untracemem(x)
```

In fact, each iteration copies the data frame not once, not twice, but three times! Two copies are made by `[[.data.frame`, and a further copy[^shallow-copy] is made because `[[.data.frame` is a regular function that increments the reference count of `x`. 

[^shallow-copy]: These copies are shallow: they only copy the reference to each individual column, not the contents of the columns. This means the performance isn't terrible, but it's obviously not as good as it could be.

We can reduce the number of copies by using a list instead of a data frame. Modifying a list uses internal C code, so the references are not incremented and no copy is made:

```{r, eval = FALSE}
y <- as.list(x)
cat(tracemem(y), "\n")
#> <0x7f80c5c3de20>
  
for (i in 1:5) {
  y[[i]] <- y[[i]] - medians[[i]]
}
```

While it's not hard to determine when a copy is made, it is hard to prevent it. If you find yourself resorting to exotic tricks to avoid copies, it may be time to rewrite your function in C++, as described in Chapter \@ref(rcpp).

### Environments {#env-modify}
\index{reference semantics}
\index{environments}

You'll learn more about environments in Chapter \@ref(environments), but it's important to mention them here because their behaviour is different from that of other objects: environments are always modified in place. This property is sometimes described as __reference semantics__ because when you modify an environment all existing bindings to that environment continue to have the same reference.

Take this environment, which we bind to `e1` and `e2`:

```{r}
e1 <- rlang::env(a = 1, b = 2, c = 3)
e2 <- e1
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/e-modify-1.png")
```

If we change a binding, the environment is modified in place:

```{r}
e1$c <- 4
e2$c
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/e-modify-2.png")
```

This basic idea can be used to create functions that "remember" their previous state. See Section \@ref(stateful-funs) for more details. This property is also used to implement the R6 object-oriented programming system, the topic of Chapter \@ref(r6).

One consequence of this is that environments can contain themselves:

```{r}
e <- rlang::env()
e$self <- e

ref(e)
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/e-self.png")
```

This is a unique property of environments!

### Exercises

1.  Explain why the following code doesn't create a circular list.

    ```{r}
    x <- list()
    x[[1]] <- x
    ```

1.  Wrap the two methods for subtracting medians into two functions, then
    use the 'bench' package [@bench] to carefully compare their speeds. How does
    performance change as the number of columns increase?

1.  What happens if you attempt to use `tracemem()` on an environment?

## Unbinding and the garbage collector {#gc}
\index{garbage collector} 
\index{unbinding}
\indexc{rm()}

Consider this code:

```{r}
x <- 1:3
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/unbinding-1.png")
```

```{r}
x <- 2:4
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/unbinding-2.png")
```

```{r}
rm(x)
```
```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/unbinding-3.png")
```

We created two objects, but by the time the code finishes, neither object is bound to a name. How do these objects get deleted? That's the job of the __garbage collector__, or GC for short. The GC frees up memory by deleting R objects that are no longer used, and by requesting more memory from the operating system if needed. 

R uses a __tracing__ GC. This means it traces every object that's reachable from the global[^callstack] environment, and all objects that are, in turn, reachable from those objects (i.e. the references in lists and environments are searched recursively). The garbage collector does not use the modify-in-place reference count described above. While these two ideas are closely related, the internal data structures are optimised for different use cases.

[^callstack]: And every environment in the current call stack.

The garbage collector (GC) runs automatically whenever R needs more memory to create a new object. Looking from the outside, it's basically impossible to predict when the GC will run. In fact, you shouldn't even try. If you want to find out when the GC runs, call `gcinfo(TRUE)` and GC will print a message to the console every time it runs.

\index{garbage collector!gc@\texttt{gc()}}
You can force garbage collection by calling `gc()`. But despite what you might have read elsewhere, there's never any _need_ to call `gc()` yourself. The only reasons you might _want_ to call `gc()` is to ask R to return memory to your operating system so other programs can use it, or for the side-effect that tells you how much memory is currently being used:   

```{r}
gc() 
```

`lobstr::mem_used()` is a wrapper around `gc()` that prints the total number of bytes used:

```{r}
mem_used()
```

This number won't agree with the amount of memory reported by your operating system. There are three reasons:

1. It includes objects created by R but not by the R interpreter.

1. Both R and the operating system are lazy: they won't reclaim memory 
   until it's actually needed. R might be holding on to memory because 
   the OS hasn't yet asked for it back.

1. R counts the memory occupied by objects but there may be empty gaps due to 
   deleted objects. This problem is known as memory fragmentation.

## Quiz answers {#names-values-answers}

1.  You must quote non-syntactic names with backticks: `` ` ``: for example,
    the variables `1`, `2`, and `3`.

    ```{r}
    df <- data.frame(runif(3), runif(3))
    names(df) <- c(1, 2)
    
    df$`3` <- df$`1` + df$`2`
    ```

1.  It occupies about 8 MB.
   
    ```{r}
    x <- runif(1e6)
    y <- list(x, x, x)
    obj_size(y)
    ```

1.  `a` is copied when `b` is modified, `b[[1]] <- 10`.
