---
title: "Memory"
author: "Abby Lewis"
date: "2023-08-10"
output: html_document
---

# Memory

This document is modified from Chapter 2 of [Advanced R](http://adv-r.had.co.nz/memory.html) by Hadley Wickham (second edition; licensed under [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/).

## Warm-up exercise

Working individually, brainstorm two ways to calculate the mean of each column of this example data frame. At least one of your ways should involve using a for loop.

```{r test-matrix}
set.seed(47)
m <- data.frame(matrix(runif(1E5, max = 100), ncol = 100))
```

As a class, implement several options as functions. Make predictions as to which options will be fastest and why

```{r}
#f1 <- function(m) {}
#f2 <- function(m) {}
#f3 <- function(m) {}
```

Use the `microbenchmark` package to compare the speed of these options

```{r}
#library(microbenchmark)
#compare <- microbenchmark(f1(m), 
#                          f2(m), 
#                          f3(m),
#                          times = 100
#                          )
#
#ggplot2::autoplot(compare)
```

Discussion questions:
* What factors make these approaches more and less efficient? 
* Do you expect the same patterns with larger datasets? Smaller datasets?
* In your own work, have there been times where code efficiency was a concern? If so, what have you done to address this concern?

## Introduction

Today we are going to take a step back and think about the distinction between an object and its name. Doing so will help you:

* More accurately predict the performance and memory usage of your code
* Write more efficient code
* Better understand R's functional programming tools (revisited in the next few weeks)

### Prerequisites

We'll use the [lobstr](https://github.com/r-lib/lobstr) package to dig into the internal representation of R objects.

```{r setup}
#install.packages("lobstr")
library(lobstr)
```

## Binding basics

Computer memory is information (like numbers or strings) that is for immediate use. When you put information there, it is located at some “address” on your computer, and you can retrieve it from that address.

```{r}
x <- c(1, 2, 3) #Puts the vector c(1, 2, 3) in memory, and binds the name x to it. 
lobstr::obj_addr(x) #See the address of this object
```

We can visualize this with a diagram:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-1.png")
```

Thus, you can think of a name as a reference to a value. For example, if you run this code, you don't get another copy of the value `c(1, 2, 3)`, you get another binding to the existing object:

```{r}
y <- x
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-2.png")
```

We can confirm that the address is the same for x and y using `lobstr::obj_addr()`

```{r}
identical(lobstr::obj_addr(x), 
          lobstr::obj_addr(y))
```

These identifiers change every time you restart R.

### Copy on modify

If you modify y, then it will make a copy of this object and point y to that new object. This is called __copy-on-modify__

```{r}
y[[3]] <- 4
lobstr::obj_addr(x) #x has the same address (x does not change when you change y -- this is good!)
lobstr::obj_addr(y) #y has a new address
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-3.png")
```

### `tracemem()`

You can use `base::tracemem()` to track whenever an object is copied. Once you call that function with an object, you'll get the object's current address. 

When using `tracemem()` interactively, you'll get different results inside of RStudio. The environment pane must make a reference to each object in order to display information about it. This distorts your interactive exploration but doesn't affect code inside of functions, and so doesn't affect performance during data analysis. 

```{r trace1, eval = FALSE}
x <- c(1, 2, 3)
tracemem(x) #displays the location of the object it is tracking
```

From then on, whenever that object is copied, `tracemem()` will print a message telling you which object was copied, its new address, and the sequence of calls that led to the copy.

If you modify `x` again, it won't get copied. That's because the new object now only has a single name bound to it, so R applies modify-in-place optimization.

You can explore this functionality interactively by modifying the function below:

```{r}
tracemem_example <- function(){
  x <- c(1, 2, 3)
  cat(tracemem(x), "\n") #initial address (using cat() to show message)
  y <- x
  y[[3]] <- 4L #copy
  x[[3]] <- 5L #no copy
  y[[3]] <- 5L #no copy
  untracemem(x) #untracemem() is the opposite of tracemem()
}

tracemem_example()
```

For loops in R have a reputation for being slow. Often that slowness can happen because you’re modifying a copy instead of modifying in place. 

For example, here is a function that tries to predict the outcome of coin flips based on past flips. Can you remove one line of code in this function to stop flip_results from being copied `n` times?

```{r}
coin_flip <- function(n) {
  flip_results <- character(n) #create flip results vector
  cat(tracemem(flip_results),'\n') #set up tracing
  predictions <- character(n) #create predictions vector
  coin <- c('heads', 'tails') #set up a "coin" 
  for (i in 1:n){
    #identify the number of heads and tails in previous flips
    previous <- flip_results
    n_heads <- sum(previous=="heads")
    n_tails <- sum(previous=="tails")
    #based on previous results, predict future coin flips
    if(n_heads==n_tails){predictions[[i]] <- "unknown!"}
    if(n_heads>n_tails){predictions[[i]] <- "heads"}
    if(n_heads<n_tails){predictions[[i]] <- "tails"}
    #flip the coin
    flip_results[[i]] <- sample(coin, size = 1)
  }
  #return predictions and results
  data.frame(predictions,flip_results)
}

results <- coin_flip(10)
results
```

An important note that has driven me crazy trying to create this demo: `tracemem()` only reports times that an object with multiple bindings is modified, creating a new copy. It does not signal anything if the object is modified and re-bound to the same name. 

For example, this function does not show a copy, despite being inefficient

```{r}
tracemem_example2 <- function(){
  x <- c(1, 2, 3)
  cat(tracemem(x), "\n")
  y <- x
  y <- y + 2
  untracemem(x)
}

tracemem_example2()
```


### Function calls

Here's a simple example of a function to illustrate how memory operates similarly inside and outside of functions:

```{r}
f <- function(a) {
  a
}

x <- c(1, 2, 3)
cat(tracemem(x), "\n")

z <- f(x)
# there's no copy here!

untracemem(x)
```

While `f()` is running, the `a` inside the function points to the same value as the `x` does outside the function:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-f1.png")
```

The function `f()` is depicted by the yellow object on the right. It has a formal argument, `a`, which becomes a binding (indicated by dotted black line) in the execution environment (the gray box) when the function is run.

Once `f()` completes, `x` and `z` will point to the same object. 

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-f2.png")
```

The object never gets copied because it never gets modified. If `f()` did modify `x`, R would create a new copy, and then `z` would bind that object.

```{r}
f <- function(a) {
  a[[1]] <- 2
}

x <- c(1, 2, 3)
tracemem(x)

z <- f(x)
# x gets copied here

untracemem(x)
```


### Lists

Recall that a list is a vector that can have elements of any type.

To do this, the list’s name points to a vector of references, and these point to the objects (note how this is different than atomic vectors!)

```{r}
l1 <- list(1, 2, 3)
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/list.png")
```

Copy on modify for a list only copies the references, so is much more memory efficient. This is called a __shallow copy__.

```{r}
l2 <- l1
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/l-modify-1.png")
```

```{r}
l2[[3]] <- 4
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/l-modify-2.png")
```

To see values that are shared across lists, use `lobstr::ref()`. `ref()` prints the memory address of each object, along with a local ID so that you can easily cross-reference shared components.

```{r}
ref(l1, l2)
```

Note that the location of the list itself is different (and therefore `tracemem()` will show a copy) unless the entire list is the same.

```{r}
l3 <- l1
ref(l1, l2, l3)
```


### Data frames {#df-modify}

Data frames are lists of vectors, so copy-on-modify has important consequences when you modify a data frame. 

```{r}
d1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/dataframe.png")
```

If you modify a column, only _that_ column needs to be modified; the others will still point to their original references:

```{r}
d2 <- d1
d2[, 2] <- d2[, 2] * 2
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/d-modify-c.png")
```

However, if you modify a row, every column is modified, which means every column must be copied:

```{r}
d3 <- d1
d3[1, ] <- d3[1, ] * 3
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/d-modify-r.png")
```

### Character vectors

R uses a __global string pool__ where each element of a character vector is a pointer to a unique string in the pool. This substantially decreases the amount of memory a character vector uses.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/character-2.png")
```

You can request that `ref()` show these references by setting the `character` argument to `TRUE`:

```{r}
x <- c("a", "a", "abc", "d")
ref(x, character = TRUE)
```

### Exercises

Explain the relationship between `a`, `b`, `c` and `d` in the following code:

```{r}
a <- 1:10
b <- a
c <- b
d <- 1:10
```

The following code accesses the mean function in multiple ways. Do they all point to the same underlying function object? Verify this with `lobstr::obj_addr()`.
    
```{r, eval = FALSE}
mean
base::mean
get("mean")
evalq(mean)
match.fun("mean")
```

Why is `tracemem(1:10)` not useful?

Sketch out the relationship between the following objects:

```{r}
a <- 1:10
b <- list(a, a)
c <- list(b, a, 1:10)
```

What happens when you run this code? Draw a picture.

```{r}
x <- list(1:10)
x[[2]] <- x
```
    
    
## Object size

You can find out how much memory an object takes with `lobstr::obj_size()`:

```{r}
obj_size(letters)
obj_size(ggplot2::diamonds)
```

Since the elements of lists are references to values, the size of a list might be much smaller than you expect:

```{r}
x <- runif(1e6)
obj_size(x)

y <- list(x, x, x)
obj_size(y)

obj_size(y)-obj_size(x)
```

`y` is only 80 bytes bigger than `x`. That's the size of an empty list with three elements:

```{r}
obj_size(list(NULL, NULL, NULL))
```

If you're running 32-bit R, you'll see slightly different sizes.

Similarly, because R uses a global string pool character vectors take up less memory than you might expect: repeating a string 100 times does not make it take up 100 times as much memory.

```{r}
banana <- "bananas bananas bananas"
obj_size(banana)
obj_size(rep(banana, 100))
```

References also make it challenging to think about the size of individual objects. `obj_size(x) + obj_size(y)` will only equal `obj_size(x, y)` if there are no shared values. Here, the combined size of `x` and `y` is the same as the size of `y`:

```{r}
obj_size(x, y)
obj_size(x, y) == obj_size(y)
```

Finally, R 3.5.0 and later versions have a feature that might lead to surprises: ALTREP, short for __alternative representation__. This allows R to represent certain types of vectors very compactly. 

The place you are most likely to see this is with `:` because instead of storing every single number in the sequence, R just stores the first and last number. This means that every sequence, no matter how large, is the same size:

```{r}
obj_size(1:3)
obj_size(1:1e3)
obj_size(1:1e6)
obj_size(1:1e9)
```

Something interesting occurs if we use object_size() to systematically explore the size of an integer vector. 

```{r}
test_range <- seq(0,10,by=1)
sizes <- sapply(test_range, function(n) obj_size(seq_len(n)))
plot(test_range, sizes, xlab = "Length", ylab = "Size (bytes)", 
  type = "s")

sizes[[1]] #An empty vector occupies 48 bites
```

While you might expect that memory usage would grow proportionately with length, the way R requests memory from the operating system is optimized for speed. 

Having to request memory every time a small vector is created would slow R down considerably. Instead, R asks for a big block of memory and then manages that block itself. This block is called the small vector pool.

### Exercises

Predict the output of the following code:

```{r, results = FALSE}
a <- runif(1e6)
obj_size(a)

b <- list(a, a)
obj_size(b)
obj_size(a, b)

b[[1]][[1]] <- 10
obj_size(b)
obj_size(a, b)

b[[2]][[1]] <- 10
obj_size(b)
obj_size(a, b)
```

## Unbinding and the garbage collector {#gc}

Consider this code:

```{r}
x <- 1:3
x <- 2:4
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/unbinding-2.png")
```

```{r}
rm(x)
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/unbinding-3.png")
```

The garbage collector (GC) frees up memory by deleting R objects that are no longer used, and by requesting more memory from the operating system if needed. 

R uses a __tracing__ GC. This means it traces every object that's reachable from the global environment, and all objects that are, in turn, reachable from those objects (i.e. the references in lists and environments are searched recursively).

The garbage collector (GC) runs automatically whenever R needs more memory to create a new object, and it is not necessary/useful to run `gc()` yourself.
