---
title: "Memory"
author: "Abby Lewis"
date: "2023-08-10"
output: html_document
---

# Names and values

This document is modified from Chapter 2 of [Advanced R](http://adv-r.had.co.nz/memory.html) by Hadley Wickham (second edition; licensed under [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/).

## Introduction

In R, it is important to understand the distinction between an object and its name. Doing so will help you:

* More accurately predict the performance and memory usage of your code. 
* Write faster code by avoiding accidental copies, a major source of slow code. 
* Better understand R's functional programming tools.

The goal of this lesson is to help you understand the distinction between names and values, and when R will copy an object.


### Objectives

* Re-introduce R fundamentals
* Understand the relationship between names and values in R
* Apply this information to predict some unintuitive properties of R
* Identify how internal data storage in R can lead to differences in code efficiency

### Resources

* http://adv-r.had.co.nz/memory.html 
* https://bookdown.org/rdpeng/RProgDA/software-testing-framework-for-r-packages.html 

### Prerequisites

We'll use the [lobstr](https://github.com/r-lib/lobstr) package to dig into the internal representation of R objects.

```{r setup}
#install.packages("lobstr")
library(lobstr)
```

## Binding basics

Computer Memory is information (like numbers or strings) that is for immediate use. When you put information there, it is located at some “address” on your computer, and you can retrieve it from that address.

The following puts the vector c(1, 2, 3) in memory, and binds the name x to it

```{r}
x <- c(1, 2, 3)
```

We can visualize this with a diagram:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-1.png")
```

Thus, you can think of a name as a reference to a value. For example, if you run this code, you don't get another copy of the value `c(1, 2, 3)`, you get another binding to the existing object:

```{r}
y <- x
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-2.png")
```

The function lobstr::obj_addr() let’s us see the address of this object. Note that it is the same for x and y

```{r}
lobstr::obj_addr(x)
lobstr::obj_addr(y)
```

These identifiers change every time you restart R.

### Copy on modify

If you modify y, then it will make a copy of this object and point y to that new object. This is called __copy-on-modify__

```{r}
y[[3]] <- 4
lobstr::obj_addr(x) #x has the same address (x does not change when you change y -- this is good!)
lobstr::obj_addr(y) #y has a new address
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-3.png")
```

### `tracemem()`

You can use `base::tracemem()` to track whenever an object is copied. Once you call that function with an object, you'll get the object's current address. 

When using `tracemem()` interactively, you'll get different results inside of RStudio. The environment pane must make a reference to each object in order to display information about it. This distorts your interactive exploration but doesn't affect code inside of functions, and so doesn't affect performance during data analysis. 

```{r trace1, eval = FALSE}
x <- c(1, 2, 3)
tracemem(x) #displays the location of the object it is tracking
```

From then on, whenever that object is copied, `tracemem()` will print a message telling you which object was copied, its new address, and the sequence of calls that led to the copy.

If you modify `x` again, it won't get copied. That's because the new object now only has a single name bound to it, so R applies modify-in-place optimization.

You can explore this functionality interactively by modifying the function below:

```{r}
tracemem_example <- function(){
  x <- c(1, 2, 3)
  cat(tracemem(x), "\n") #initial address (using cat() to show message)
  y <- x
  y[[3]] <- 4L #copy
  x[[3]] <- 5L #no copy
  y[[3]] <- 5L #no copy
  untracemem(x) #untracemem() is the opposite of tracemem()
}

tracemem_example()
```

`untracemem()` is the opposite of `tracemem()`; it turns tracing off.

### Function calls

How would you diagram what happens within a function? Here's an example:

```{r}
f <- function(a) {
  a
}

x <- c(1, 2, 3)
cat(tracemem(x), "\n")

z <- f(x)
# there's no copy here!

untracemem(x)
```

While `f()` is running, the `a` inside the function points to the same value as the `x` does outside the function:

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-f1.png")
```

The function `f()` is depicted by the yellow object on the right. It has a formal argument, `a`, which becomes a binding (indicated by dotted black line) in the execution environment (the gray box) when the function is run.

Once `f()` completes, `x` and `z` will point to the same object. 

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/binding-f2.png")
```

The object never gets copied because it never gets modified. If `f()` did modify `x`, R would create a new copy, and then `z` would bind that object.

```{r}
f <- function(a) {
  a[[1]] <- 2
}

x <- c(1, 2, 3)
tracemem(x)

z <- f(x)
# x gets copied here

untracemem(x)
```


### Lists

Recall that a list is a vector that can have elements of any type.

To do this, the list’s name points to a vector of references, and these point to the objects (note how this is different than atomic vectors!)

```{r}
l1 <- list(1, 2, 3)
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/list.png")
```

Copy on modify for a list only copies the references, so is much more memory efficient. This is called a __shallow copy__.

```{r}
l2 <- l1
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/l-modify-1.png")
```

```{r}
l2[[3]] <- 4
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/l-modify-2.png")
```

To see values that are shared across lists, use `lobstr::ref()`. `ref()` prints the memory address of each object, along with a local ID so that you can easily cross-reference shared components.

```{r}
ref(l1, l2)
```

### Data frames {#df-modify}

Data frames are lists of vectors, so copy-on-modify has important consequences when you modify a data frame. 

```{r}
d1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/dataframe.png")
```

If you modify a column, only _that_ column needs to be modified; the others will still point to their original references:

```{r}
d2 <- d1
d2[, 2] <- d2[, 2] * 2
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/d-modify-c.png")
```

However, if you modify a row, every column is modified, which means every column must be copied:

```{r}
d3 <- d1
d3[1, ] <- d3[1, ] * 3
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/d-modify-r.png")
```

### Character vectors

R uses a __global string pool__ where each element of a character vector is a pointer to a unique string in the pool. This substantially decreases the amount of memory a character vector uses.

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/character-2.png")
```

You can request that `ref()` show these references by setting the `character` argument to `TRUE`:

```{r}
x <- c("a", "a", "abc", "d")
ref(x, character = TRUE)
```

### Exercises

Explain the relationship between `a`, `b`, `c` and `d` in the following code:

```{r}
a <- 1:10
b <- a
c <- b
d <- 1:10
```

The following code accesses the mean function in multiple ways. Do they all point to the same underlying function object? Verify this with `lobstr::obj_addr()`.
    
```{r, eval = FALSE}
mean
base::mean
get("mean")
evalq(mean)
match.fun("mean")
```

Why is `tracemem(1:10)` not useful?

Sketch out the relationship between the following objects:

```{r}
a <- 1:10
b <- list(a, a)
c <- list(b, a, 1:10)
```

What happens when you run this code? Draw a picture.

```{r}
x <- list(1:10)
x[[2]] <- x
```
    
    
## Object size

You can find out how much memory an object takes with `lobstr::obj_size()`:

```{r}
obj_size(letters)
obj_size(ggplot2::diamonds)
```

Since the elements of lists are references to values, the size of a list might be much smaller than you expect:

```{r}
x <- runif(1e6)
obj_size(x)

y <- list(x, x, x)
obj_size(y)

obj_size(y)-obj_size(x)
```

`y` is only 80 bytes bigger than `x`. That's the size of an empty list with three elements:

```{r}
obj_size(list(NULL, NULL, NULL))
```

If you're running 32-bit R, you'll see slightly different sizes.

Similarly, because R uses a global string pool character vectors take up less memory than you might expect: repeating a string 100 times does not make it take up 100 times as much memory.

```{r}
banana <- "bananas bananas bananas"
obj_size(banana)
obj_size(rep(banana, 100))
```

References also make it challenging to think about the size of individual objects. `obj_size(x) + obj_size(y)` will only equal `obj_size(x, y)` if there are no shared values. Here, the combined size of `x` and `y` is the same as the size of `y`:

```{r}
obj_size(x, y)
obj_size(x, y) == obj_size(y)
```

Finally, R 3.5.0 and later versions have a feature that might lead to surprises: ALTREP, short for __alternative representation__. This allows R to represent certain types of vectors very compactly. 

The place you are most likely to see this is with `:` because instead of storing every single number in the sequence, R just stores the first and last number. This means that every sequence, no matter how large, is the same size:

```{r}
obj_size(1:3)
obj_size(1:1e3)
obj_size(1:1e6)
obj_size(1:1e9)
```

Something interesting occurs if we use object_size() to systematically explore the size of an integer vector. 

```{r}
max <- 10
sizes <- sapply(0:max, function(n) obj_size(seq_len(n)))
plot(0:max, sizes, xlab = "Length", ylab = "Size (bytes)", 
  type = "s")
sizes[[1]]
```

While you might expect that memory usage would grow proportionately with length, the way R requests memory from the operating system is optimized for speed. 

Having to request memory every time a small vector is created would slow R down considerably. Instead, R asks for a big block of memory and then manages that block itself. This block is called the small vector pool.

```{r}
test_range <- seq(0,10,by=1)
sizes <- sapply(test_range, function(n) obj_size(seq_len(n)))
plot(test_range, sizes, xlab = "Length", ylab = "Size (bytes)", 
  type = "s")

sizes[[1]] #An empty vector occupies 48 bites
```

### Exercises

Predict the output of the following code:

```{r, results = FALSE}
a <- runif(1e6)
obj_size(a)

b <- list(a, a)
obj_size(b)
obj_size(a, b)

b[[1]][[1]] <- 10
obj_size(b)
obj_size(a, b)

b[[2]][[1]] <- 10
obj_size(b)
obj_size(a, b)
```

Let's explore the subtleties with a case study using for loops. For loops have a reputation for being slow in R, but often that slowness is caused by every iteration of the loop creating a copy. Consider the following code. It subtracts the median from each column of a large data frame: 

```{r, cache = TRUE}
x <- data.frame(matrix(runif(5 * 1e4), ncol = 5))
medians <- vapply(x, median, numeric(1))

for (i in seq_along(medians)) {
  x[[i]] <- x[[i]] - medians[[i]]
}
```

This loop is surprisingly slow because each iteration of the loop copies the data frame. You can see this by using `tracemem()`:

```{r, eval = FALSE}
medians <- vapply(x, median, numeric(1))

for_loop_example <- function(){
  cat(tracemem(x), "\n")

  for (i in 1:5) {
    x[[i]] <- x[[i]] - medians[[i]]
  }
  
  untracemem(x)
}

for_loop_example()
```

In fact, each iteration copies the data frame not once, not twice, but three times! Two copies are made by `[[.data.frame`, and a further copy is made because `[[.data.frame` is a regular function that increments the reference count of `x`. 

We can reduce the number of copies by using a list instead of a data frame. Modifying a list uses internal C code, so the references are not incremented and no copy is made:

```{r, eval = FALSE}
y <- as.list(x)
cat(tracemem(y), "\n")
#> <0x7f80c5c3de20>
  
for (i in 1:5) {
  y[[i]] <- y[[i]] - medians[[i]]
}
```

While it's not hard to determine when a copy is made, it is hard to prevent it. If you find yourself resorting to exotic tricks to avoid copies, it may be time to rewrite your function in C++


### Exercises

Wrap the two methods for subtracting medians into two functions, then
use the 'bench' package [@bench] to carefully compare their speeds. How does
performance change as the number of columns increase?

## Unbinding and the garbage collector {#gc}

Consider this code:

```{r}
x <- 1:3
x <- 2:4
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/unbinding-2.png")
```

```{r}
rm(x)
```

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/name-value/unbinding-3.png")
```

The garbage collector (GC) frees up memory by deleting R objects that are no longer used, and by requesting more memory from the operating system if needed. 

R uses a __tracing__ GC. This means it traces every object that's reachable from the global environment, and all objects that are, in turn, reachable from those objects (i.e. the references in lists and environments are searched recursively).

The garbage collector (GC) runs automatically whenever R needs more memory to create a new object, and it is not necessary/useful to run `gc()` yourself.

### Loops

For loops in R have a reputation for being slow. Often that slowness is because you’re modifying a copy instead of modifying in place. Consider the following code. It subtracts the median from each column of a large data frame:

```{r}
x <- data.frame(matrix(runif(100 * 1e4), ncol = 100))
medians <- vapply(x, median, numeric(1))

for(i in seq_along(medians)) {
  x[, i] <- x[, i] - medians[i]
  print(c(obj_addr(x))) #Different each time
}
```

If we do this as a list, the object doesn't have to be copied every time

```{r}
y <- as.list(x)
for(i in seq_along(medians)) {
  y[[i]] <- y[[i]] - medians[i]
  print(c(obj_addr(y))) #The same each time
}
```



